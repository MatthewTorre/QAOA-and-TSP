# -*- coding: utf-8 -*-
"""Physics 14N: QAOA Demo  for Solving TSP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r5rJy0-MADJ8McjvYRKZZ0JkzpX_pwtj
"""

# code adapted from text conversation with various LLMs including GPT-4 and the following Github repositories:
# https://github.com/aubreycoffey/TSP-Quantum-Computing/blob/main/quantum_algorithms/objective.py

!pip install cirq
import cirq
import cirq_google
!pip install cirq
!pip install matplotlib
!pip install networkx


# Test the installation by printing the Sycamore chip
print(cirq_google.Sycamore)

# Import necessary libraries
import cirq
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Define the TSP problem with new distances
cities = [0, 1, 2, 3]
new_distances = {(0, 1): 10, (0, 2): 15, (0, 3): 20,
                 (1, 2): 35, (1, 3): 25,
                 (2, 3): 30}

# Create a graph for the TSP problem
G = nx.Graph()
for (i, j), dist in new_distances.items():
    G.add_edge(i, j, weight=dist)

# Visualize the initial graph with distances
pos = nx.spring_layout(G)
plt.figure(figsize=(12, 12))
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Initial Graph of TSP Problem with 4 Cities and New Distances")
plt.show()

# Define a function to create a cost Hamiltonian
def create_cost_hamiltonian(graph):
    qubits = cirq.LineQubit.range(len(graph.nodes))
    cost_hamiltonian = sum(graph[i][j]['weight'] * (1 - cirq.Z(qubits[i]) * cirq.Z(qubits[j])) for i, j in graph.edges)
    return cost_hamiltonian, qubits

# Create the cost Hamiltonian
cost_hamiltonian, qubits = create_cost_hamiltonian(G)

# Define the mixer Hamiltonian
def create_mixer_hamiltonian(qubits):
    mixer_hamiltonian = sum(cirq.X(qubit) for qubit in qubits)
    return mixer_hamiltonian

mixer_hamiltonian = create_mixer_hamiltonian(qubits)

# Define a function to create the QAOA circuit
def create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p):
    circuit = cirq.Circuit()
    for i in range(p):
        circuit.append(cirq.ZZPowGate(exponent=-gamma[i])(qubits[j], qubits[j+1]) for j in range(len(qubits) - 1))
        circuit.append(cirq.X(qubit) ** beta[i] for qubit in qubits)
    # Add measurement operations
    circuit.append(cirq.measure(*qubits, key='result'))
    return circuit

# Correct the number of elements in gamma and beta
p = 1
gamma = [np.pi / 4] * p
beta = [np.pi / 4] * p

# Create the QAOA circuit
qaoa_circuit = create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p)

# Simulate the circuit
simulator = cirq.Simulator()
result = simulator.run(qaoa_circuit, repetitions=1000)

# Analyze the results
def get_most_common_bitstring(result):
    hist = result.histogram(key='result')
    most_common = max(hist, key=hist.get)
    # Convert integer to bitstring
    bitstring = format(most_common, f'0{len(qubits)}b')
    return bitstring

most_common_bitstring = get_most_common_bitstring(result)
print(f"Most common bitstring: {most_common_bitstring}")

# Convert bitstring to TSP tour
def bitstring_to_tour(bitstring):
    tour = []
    for i in range(len(bitstring)):
        if bitstring[i] == '1':
            tour.append(i)
    return tour

tsp_tour = bitstring_to_tour(most_common_bitstring)
print(f"TSP Tour: {tsp_tour}")

# Visualize the TSP solution
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

# Highlight the optimal tour
tour_edges = [(tsp_tour[i], tsp_tour[i+1]) for i in range(len(tsp_tour)-1)] + [(tsp_tour[-1], tsp_tour[0])]
nx.draw_networkx_edges(G, pos, edgelist=tour_edges, edge_color='r', width=2)

plt.title("TSP Solution with 4 Cities Using QAOA and New Distances")
plt.show()

# Import necessary libraries
import cirq
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Define a larger TSP problem
cities = list(range(8))
distances = {
    (0, 1): 2, (0, 2): 9, (0, 3): 10, (0, 4): 7, (0, 5): 3, (0, 6): 1, (0, 7): 6,
    (1, 2): 6, (1, 3): 4, (1, 4): 3, (1, 5): 8, (1, 6): 5, (1, 7): 2,
    (2, 3): 1, (2, 4): 8, (2, 5): 4, (2, 6): 7, (2, 7): 3,
    (3, 4): 3, (3, 5): 6, (3, 6): 2, (3, 7): 5,
    (4, 5): 1, (4, 6): 6, (4, 7): 4,
    (5, 6): 2, (5, 7): 3,
    (6, 7): 8
}

# Create a graph for the TSP problem
G = nx.Graph()
for (i, j), dist in distances.items():
    G.add_edge(i, j, weight=dist)

# Visualize the initial graph with new distances
pos = nx.spring_layout(G)
plt.figure(figsize=(12, 12))
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Initial Graph of TSP Problem with 8 Cities and New Distances")
plt.show()

# Define a function to create a cost Hamiltonian
def create_cost_hamiltonian(graph):
    qubits = cirq.LineQubit.range(len(graph.nodes))
    cost_hamiltonian = sum(graph[i][j]['weight'] * (1 - cirq.Z(qubits[i]) * cirq.Z(qubits[j])) for i, j in graph.edges)
    return cost_hamiltonian, qubits

# Create the cost Hamiltonian
cost_hamiltonian, qubits = create_cost_hamiltonian(G)

# Define the mixer Hamiltonian
def create_mixer_hamiltonian(qubits):
    mixer_hamiltonian = sum(cirq.X(qubit) for qubit in qubits)
    return mixer_hamiltonian

mixer_hamiltonian = create_mixer_hamiltonian(qubits)

# Define a function to create the QAOA circuit
def create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p):
    circuit = cirq.Circuit()
    for i in range(p):
        circuit.append(cirq.ZZPowGate(exponent=-gamma[i])(qubits[j], qubits[j+1]) for j in range(len(qubits) - 1))
        circuit.append(cirq.X(qubit) ** beta[i] for qubit in qubits)
    # Add measurement operations
    circuit.append(cirq.measure(*qubits, key='result'))
    return circuit

# Correct the number of elements in gamma and beta
p = 1
gamma = [np.pi / 4] * p
beta = [np.pi / 4] * p

# Create the QAOA circuit
qaoa_circuit = create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p)

# Simulate the circuit
simulator = cirq.Simulator()
result = simulator.run(qaoa_circuit, repetitions=1000)

# Analyze the results
def get_most_common_bitstring(result):
    hist = result.histogram(key='result')
    most_common = max(hist, key=hist.get)
    # Convert integer to bitstring
    bitstring = format(most_common, f'0{len(qubits)}b')
    return bitstring

most_common_bitstring = get_most_common_bitstring(result)
print(f"Most common bitstring: {most_common_bitstring}")

# Convert bitstring to TSP tour
def bitstring_to_tour(bitstring):
    tour = []
    for i in range(len(bitstring)):
        if bitstring[i] == '1':
            tour.append(i)
    return tour

tsp_tour = bitstring_to_tour(most_common_bitstring)
print(f"TSP Tour: {tsp_tour}")

# Visualize the TSP solution
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

# Highlight the optimal tour
tour_edges = [(tsp_tour[i], tsp_tour[i+1]) for i in range(len(tsp_tour)-1)] + [(tsp_tour[-1], tsp_tour[0])]
nx.draw_networkx_edges(G, pos, edgelist=tour_edges, edge_color='r', width=2)

plt.show()

# Import necessary libraries
import cirq
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Define a TSP problem with 15 cities
num_cities = 15
cities = list(range(num_cities))

# Generate random distances for the TSP problem
np.random.seed(0)
distances = {}
for i in range(num_cities):
    for j in range(i+1, num_cities):
        distances[(i, j)] = np.random.randint(1, 100)

# Create a graph for the TSP problem
G = nx.Graph()
for (i, j), dist in distances.items():
    G.add_edge(i, j, weight=dist)

# Visualize the initial graph with new distances
pos = nx.spring_layout(G)
plt.figure(figsize=(12, 12))
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Initial Graph of TSP Problem with 15 Cities and New Distances")
plt.show()

# Define a function to create a cost Hamiltonian
def create_cost_hamiltonian(graph):
    qubits = cirq.LineQubit.range(len(graph.nodes))
    cost_hamiltonian = sum(graph[i][j]['weight'] * (1 - cirq.Z(qubits[i]) * cirq.Z(qubits[j])) for i, j in graph.edges)
    return cost_hamiltonian, qubits

# Create the cost Hamiltonian
cost_hamiltonian, qubits = create_cost_hamiltonian(G)

# Define the mixer Hamiltonian
def create_mixer_hamiltonian(qubits):
    mixer_hamiltonian = sum(cirq.X(qubit) for qubit in qubits)
    return mixer_hamiltonian

mixer_hamiltonian = create_mixer_hamiltonian(qubits)

# Define a function to create the QAOA circuit
def create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p):
    circuit = cirq.Circuit()
    for i in range(p):
        circuit.append(cirq.ZZPowGate(exponent=-gamma[i])(qubits[j], qubits[j+1]) for j in range(len(qubits) - 1))
        circuit.append(cirq.X(qubit) ** beta[i] for qubit in qubits)
    # Add measurement operations
    circuit.append(cirq.measure(*qubits, key='result'))
    return circuit

# Correct the number of elements in gamma and beta
p = 1
gamma = [np.pi / 4] * p
beta = [np.pi / 4] * p

# Create the QAOA circuit
qaoa_circuit = create_qaoa_circuit(cost_hamiltonian, mixer_hamiltonian, qubits, gamma, beta, p)

# Simulate the circuit
simulator = cirq.Simulator()
result = simulator.run(qaoa_circuit, repetitions=1000)

# Analyze the results
def get_most_common_bitstring(result):
    hist = result.histogram(key='result')
    most_common = max(hist, key=hist.get)
    # Convert integer to bitstring
    bitstring = format(most_common, f'0{len(qubits)}b')
    return bitstring

most_common_bitstring = get_most_common_bitstring(result)
print(f"Most common bitstring: {most_common_bitstring}")

# Convert bitstring to TSP tour
def bitstring_to_tour(bitstring):
    tour = []
    for i in range(len(bitstring)):
        if bitstring[i] == '1':
            tour.append(i)
    return tour

tsp_tour = bitstring_to_tour(most_common_bitstring)
print(f"TSP Tour: {tsp_tour}")

# Visualize the TSP solution
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=500, edge_color='gray')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

# Highlight the optimal tour (if the solution is feasible to visualize)
if len(tsp_tour) > 1:
    tour_edges = [(tsp_tour[i], tsp_tour[i+1]) for i in range(len(tsp_tour)-1)] + [(tsp_tour[-1], tsp_tour[0])]
    nx.draw_networkx_edges(G, pos, edgelist=tour_edges, edge_color='r', width=2)

plt.show()